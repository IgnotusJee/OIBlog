<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初赛学习笔记</title>
    <link href="/2020/10/10/%E5%88%9D%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/10/10/%E5%88%9D%E8%B5%9B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="主定理："><a href="#主定理：" class="headerlink" title="主定理："></a>主定理：</h1><script type="math/tex; mode=display">T ( n ) = aT(\frac{n}{b}) + f(n) \\\texttt{设 } f(n) = n ^ t \\\Rightarrow \\O(n)=\begin{cases}n^{log_ba} \quad ,  \quad log_ba > t \\ n^{log_ba}logn \quad ,\quad log_ba=t \\f(n) \quad , \quad log_ba < t\end{cases}</script><h1 id="特征方程："><a href="#特征方程：" class="headerlink" title="特征方程："></a>特征方程：</h1><p>对于形如$ a \, f<em>{n} = b \, f</em>{n-1} + c \, f_{n-2} \: , \: f_0 = p \: , \: f_1 = q $的递推式，试求出$ f_n $的通项公式。</p><p>将递推式中的最低项换成$1$，次低项换成$x$，次次低项换成$x^2$，以此类推。解方程，得到两个根：$x_1,x_2$。</p><p>发现数列${h<em>i = {x_1} ^ i}$和$g_i = {x </em> 2} ^ i$均能满足原递推式。设$ f <em> n = \alpha \times {x_1} ^ n + \beta \times {x </em> 2}^ n $ ，将初始条件带入即得解。</p><h1 id="浮点数标准-IEEE-754"><a href="#浮点数标准-IEEE-754" class="headerlink" title="浮点数标准 IEEE 754"></a>浮点数标准 IEEE 754</h1><p>一个浮点数的表示：$Value = sign \times exponent \times fraction$，$sign$为符号位，$exponent$为指数偏移值（即指数大小），$fraction$为分数值（有效数位值）。其存储实质为二进制小数。</p><p>为了表示指数的符号，使用指数偏差，将指数编码制限制在无符号整数范围内，即指数实际值为指数的编码制减去指数偏差值。指数偏差值为一个固定值，若存储指数的比特长度为$e$，则指数偏差值为$2^{e-1}-1$。移码表示的指数部分成为阶码。</p><p>如果浮点数中指数部分的编码值在$0&lt;exponent&lt;2^e-2$之间，且在科学表示法的表示方式下，分数部分最高有效位（即整数字）是1，那么这个浮点数将被称为<strong>规约形式的浮点数</strong>。“规约”是指用唯一确定的浮点形式去表示一个值。</p><p>非规约浮点数的绝对值比所有规约浮点数更接近于零。</p><div class="table-container"><table><thead><tr><th>形式</th><th>指数</th><th>小数部分</th></tr></thead><tbody><tr><td>正负零</td><td>$0$</td><td>$0$</td></tr><tr><td>非规约形式</td><td>$0$</td><td>非$0$</td></tr><tr><td>规约形式</td><td>$\left[ \: 1 \: , \: 2^e-2 \: \right]$</td><td>任意</td></tr><tr><td><code>Inf</code></td><td>$2^e-1$</td><td>$0$</td></tr><tr><td><code>NaN</code></td><td>$2^e-1$</td><td>非$0$</td></tr></tbody></table></div><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>建树方法：初始若干节点组成森林，选择根权值最小的两棵树合并，其父节点为新建节点，权值为两节点点权之和。这样可以使合并的总花费，即每次合并新的根节点的权值和(带权路径长度)最小。</p><p>哈夫曼编码：将建好的哈夫曼树连向左儿子的边标<code>0</code>，连向右儿子的边标$1$，每个字母的编码即为根到其路径上边的数字以此写下来。容易看出这样没有一个字母的编码是另一个字母的前缀。</p><h1 id="计算机常识"><a href="#计算机常识" class="headerlink" title="计算机常识"></a>计算机常识</h1><h2 id="计算机发展"><a href="#计算机发展" class="headerlink" title="计算机发展"></a>计算机发展</h2><p>计算机元件发展：电子管 $\rightarrow$ 晶体管 $\rightarrow$ 集成电路 $\rightarrow$ 大规模集成电路</p><p>1946年2月，在美国宾夕法尼亚大学诞生了世界上第一台电子计算机<strong>ENIAC</strong>(电子管计算机)。</p><p>计算机分为巨型机，大、中型机，小型机，微型机，工作站等。</p><p>第一个编程的人叫<strong>Ada Lovelace</strong>。</p><h2 id="冯-·-诺依曼结构"><a href="#冯-·-诺依曼结构" class="headerlink" title="冯 · 诺依曼结构"></a>冯 · 诺依曼结构</h2><p>所有计算机的基本结构。</p><ol><li><p>计算机硬件设备由存储器、运算器、控制器、输入设备和输出设备5部分组成。</p></li><li><p><strong>存储程序思想</strong>——把计算过程描述为由许多命令按一定顺序组成的程序，然后把程序和数据一起输入计算机，计算机对已存入的程序和数据处理后，输出结果。</p></li></ol><h2 id="微型计算机指标"><a href="#微型计算机指标" class="headerlink" title="微型计算机指标"></a>微型计算机指标</h2><ol><li><p>字长：指计算机能够直接处理的二进制数据的位数。单位为位（BIT）。（即计算机位数，决定了最大寻址空间，如$32$位系统为$4GB$）</p></li><li><p>主频：指<strong>计算机主时钟在一秒钟内发出的脉冲数，即CPU的时钟频率</strong>，在很大程度上决定了计算机的运算速度。单位<script type="math/tex">Hz</script>。</p></li><li><p>运算速度：是指CPU每秒能执行的指令条数。单位：每秒执行百万条指令（MIPS）。</p></li><li><p>存储容量：存储器所能储存的字节数。</p></li><li>系统总线的传输速率：直接影响输入输出的性能，它与总线中的数据宽度及总线周期有关。</li><li>外部设备配置</li><li>软件配置</li></ol><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><blockquote><p>存储器可分为主存储器(简称主存或内存)和辅助存储器(简称辅存或外存)两大类。和CPU直接交换信息的是主存。</p><p>主存的工作方式是按存储单元的地址存放或读取各类信息，统称访问存储器。主存中汇集存储单元的载体称为存储体，存储体中每个单元能够存放一串二进制码表示的信息，该信息的总位数称为一个存储单元的字长。存储单元的地址与存储在其中的信息是一一对应的，单元地址只有一个，固定不变，而存储在其中的信息是可以更换的。</p><p>指示每个单元的二进制编码称为地址码。寻找某个单元时，先要给出它的地址码。暂存这个地址码的寄存器叫存储器地址寄存器(MAR)。为可存放从主存的存储单元内取出的信息或准备存入某存储单元的信息，还要设置一个存储器数据寄存器(MDR)。</p><p>——百度百科</p></blockquote><p>内存储器有$RAM$(随机存储器)，$ROM$(只读存储器)，$Cache$(高速缓存储器)等。前两者为<strong>主存</strong>。</p><p>外存储器有硬盘、软盘、光盘存储器(只读，存储量约650MB)等。</p><p>寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果。它是CPU内部的存储结构，拥有最快的访问速度。</p><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><p>按照总线上传输信息的不同，总线可以分为数据总线（DB），地址总线（AB）和控制总线（CB）三种。</p><ol><li>数据总线：用来传送数据信息，它主要连接了CPU与各个部件，是它们之间交换信息的通路。数据总线是双向的，而具体的传送方向由CPU控制。</li><li>地址总线：用来传送地址信息。CPU通过地址总线中传送的地址信息访问存储器。通常地址总线是单向的。同时，地址总线的宽度决定可以访问的存储器容量大小，如20条地址总线可以控制1MB的存储空间。<strong>决定了CPU能访问的最大存储器容量</strong>。</li><li>控制总线：用来传送控制信号，以协调各部件之间的操作。控制信号包括CPU对内存储器和接口电路的读写控制信号、中断响应信号，也包括其他部件传送给CPU的信号，如中断申请信号、准备就绪信号等。</li></ol><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU由控制器、运算器和寄存器组成。运算器的基本操作包括加、减、乘、除四则运算，与、或、非、异或等逻辑操作，以及移位、比较和传送等操作，亦称算术逻辑部分(ALU)。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h3><p>IOS,Android,VxWorks,eCos,Symbian OS,Palm OS,鸿蒙等。</p><h3 id="UNIX及类UNIX系统"><a href="#UNIX及类UNIX系统" class="headerlink" title="UNIX及类UNIX系统"></a>UNIX及类UNIX系统</h3><p>System V,BSD,Linux,MacOS X。</p><h4 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h4><p>Debian,Ubuntu,Linux Mint,openSUSE,Fedora,Mandrake,Red Hat,Centos,Deepin,Manjaro,UOS……</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>95,98,2000,me,xp,vista,7,8,8.1,10。</p><h3 id="浏览器内核操作系统"><a href="#浏览器内核操作系统" class="headerlink" title="浏览器内核操作系统"></a>浏览器内核操作系统</h3><p>Google Chrome OS,Fyde OS。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><p>广域网（WAN），局域网（LAN），城域网（MAN）。</p><h3 id="计算机网络的拓扑结构"><a href="#计算机网络的拓扑结构" class="headerlink" title="计算机网络的拓扑结构"></a>计算机网络的拓扑结构</h3><p>总线型，环形，星形。</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>目前全球最大的网络Internet所采用的是TCP/IP协议。</p><p>其层次结构：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><strong>应用层（直接支持用户的通信协议）</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>传输层（传输控制协议TCP）</strong></td></tr><tr><td style="text-align:center"><strong>网络层（网际协议IP）</strong></td></tr><tr><td style="text-align:center"><strong>网络接口层（主机到网络）</strong></td></tr></tbody></table></div><p>用户与用户通信时，信息从网络接口层到应用层，传输后再从应用层到网络接口层。</p><h3 id="IP地址与域名"><a href="#IP地址与域名" class="headerlink" title="IP地址与域名"></a>IP地址与域名</h3><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>主机在网络上的唯一标识。IP地址的构成为网络号加主机号，网络号表示其所属的网络段编号，主机号则表示该网段中该主机的地址编号。</p><h4 id="ipv4"><a href="#ipv4" class="headerlink" title="ipv4"></a>ipv4</h4><p>地址长度为<script type="math/tex">32</script><strong>位</strong>(4字节)。每一位取值范围为$[0,255]$。</p><p><strong>点分表示法</strong>：把这32位的二进制数平均分成4组，每组用一个十进制数来表示，组和组之间用$\texttt{“.”}$作为分隔符。如：$\texttt{61.139.2.69}\texttt{,127.0.0.1(本地地址)}$</p><p>2019年11月26日，全球所有43亿个IPv4地址已分配完毕。</p><h4 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h4><p>地址长度为$128$位，是$\texttt{ipv4}$的$4$倍。采用时有</p><p><strong>十六进制冒分表示法</strong>：$8$位，每一位取值范围也是$[0,255]$。分隔符为$\texttt{“:”}$，可以省略前导零。如$\texttt{CDCD:910A:2222:5498:8475:1111:3900:2020,}\texttt{1030::C9B4:FF12:48AA:1A2B}$。注意第一段位上连续的$0$可以被压缩，使用$\texttt{“::”}$代替。</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网掩码的作用就是和IP地址“与”运算后得出网络地址。</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>域名与IP地址互相映射，DNS服务器负责解析。</p><p>常用的顶级域名有：.com（商业机构），.edu（教育机构），.gov（政府机构），.int（国际组织），.mil（军事组织），.net（网络服务机构），.org（非盈利机构），.cn（中国域名），.jp（日本域名）……</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><img src="https://i.loli.net/2020/10/10/H3ti4oSWcMYhjvZ.png" alt="class.png"></p><p><img src="https://i.loli.net/2020/10/10/ZVwRAM2Dm9v8jBd.png" alt="sort.png"></p><h1 id="排列与组合"><a href="#排列与组合" class="headerlink" title="排列与组合"></a>排列与组合</h1><h2 id="排列数"><a href="#排列数" class="headerlink" title="排列数"></a>排列数</h2><p>$P_n^m$表示从$n$个不同元素中选出$m$个$(m\le n)$组成有序排列的方案数。</p><script type="math/tex; mode=display">P_n^m = P(n,m) =\frac{n!}{(n-m)!}</script><h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$C_n^m$表示从$n$个不同元素中无序选出$m$个$(m\le n)$的方案数。</p><script type="math/tex; mode=display">C_n^m = C(n,m) = \frac{n!}{m!(n-m)!} = \frac{P_n^m}{m!} \\P_n^m = C_n^m \times m!</script><p>其性质有：</p><script type="math/tex; mode=display">C_n^m = C_n^{(n-m)} \: (m\le n) \: , \\C_n^m = C_{n-1}^m + C_{n-1}^{m-1} \: (m \le n)</script><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><script type="math/tex; mode=display">\begin{array}{lcl}f_n \\= f_0 \times f_{n-1} + f_1 \times f_{n-2} + \cdots + f_{n-1}\times f_0 \\= \frac{4n-2}{n+1}f_{n-1} \\= \frac{1}{n+1}C_{2n}^n \\= C_{2n}^n - C_{2n}^{n-1}\end{array}</script><p><del>一句话，题想不出，卡特兰数</del></p><h3 id="卡特兰数能解决的问题"><a href="#卡特兰数能解决的问题" class="headerlink" title="卡特兰数能解决的问题"></a>卡特兰数能解决的问题</h3><ul><li>在一个$w×h$的网格上，最开始在$(0,0)$上，每个单位时间可以向上走一格，或者向右走一格，在任意一个时刻，往右走的次数都不能少于往上走的次数，问走到$(n,m),0\le n\le w,0 \le m \le h$有多少种不同的合法路径。</li><li>现有$n$个$0$和$n$个$1$，问有多少个长度为$2n$的序列，使得序列的任意一个前缀中$1$的个数都大于等于$0$的个数。</li><li>有$n$个左括号，$n$个右括号，问有多少个长度为$2n$的括号序列使得所有的括号都是合法的。</li><li>有$n$个点，问用这$n$个点最终能构成多少二叉树。</li><li>一个凸的$n$边形，用直线连接他的两个顶点使之分成多个三角形，每条直线不能相交，问一共有多少种划分方案。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>初赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法笔记-莫队二次离线</title>
    <link href="/2020/09/15/CaptainMoTwiceOffine/"/>
    <url>/2020/09/15/CaptainMoTwiceOffine/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>莫队</tag>
      
      <tag>lxl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷3684 [CERC2016]机棚障碍 Hangar Hurdles 题解</title>
    <link href="/2020/09/13/SolutionOfHangarHurdles/"/>
    <url>/2020/09/13/SolutionOfHangarHurdles/</url>
    
    <content type="html"><![CDATA[<p>并查集写成<code>Merge(e[i].v,e[i].v)</code>调了三天奥里给都给我调出来了。<del>不过这都70分可见数据有多水</del></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给定一个$n\times n$的网格图，其中部分格点有障碍物使得箱子不能置于其上。规定箱子是一个奇数边长的正方形，其坐标为其中心格点的坐标。箱子只能上下左右移动，每次询问从一个格点能移动到另一个格点的最大箱子。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>此题看似简单，实则恶心的一匹。</p><ul><li>我们先考虑将问题转化。如果求出每个格点能放置的最大箱子，设为格点权，那么每次询问就变成了求出两点路径上最小点权最大的路径。每次bfs，复杂度无法承受。</li><li>接着发现联通的点权相同的格点可以缩成一个点，因为在这个联通块内移动是不会改变经过的最小点权的。</li><li>于是在上下左右四个方向移动转化为了在相邻的联通块内移动。我们可以在相邻的联通块内连边，将边权设为两点点权的最小值，于是只要求出最大瓶颈路就可以了。</li><li>任意两点间的最大瓶颈路可以用如下算法求：将边降序排序，依次加入图中，两点第一次联通时其路径即为最大瓶颈路。正确性显然。</li><li>发现这就是Kruskal求最大生成树的过程，于是只要在生成树上查询路径最小值就可以了。</li></ul><p>经过以上转化，此题解决（指口头）。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>实现才是这道题的重头戏。</p><h2 id="part1-求出MaxSize"><a href="#part1-求出MaxSize" class="headerlink" title="part1 求出MaxSize"></a>part1 求出MaxSize</h2><ul><li><p>首先设图中障碍为1，其余为0，对原图进行前缀和，以快速求出目标矩阵中有没有障碍物。</p></li><li><p>对每个格点进行二分，得到每个格点能放置的最大箱子设为MaxSize。其中因为边长只能为奇数，二分时是对中心点到边界的距离进行二分。</p></li><li><p>复杂度$O(n^2logn)$</p><p>代码：</p><pre><code class="hljs cpp"><span class="hljs-comment">//第一部分：预处理出每个点的最大矩形</span><span class="hljs-keyword">namespace</span> DealMatrix &#123;  <span class="hljs-keyword">int</span> sum[maxn][maxn];<span class="hljs-comment">//前缀和，障碍为1</span>  <span class="hljs-keyword">int</span> maxsize[maxn][maxn];  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;j,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;s)</span> </span>&#123;      <span class="hljs-keyword">if</span>(i-s&lt;<span class="hljs-number">1</span>||j-s&lt;<span class="hljs-number">1</span>||i+s&gt;n||j+s&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//大了</span>      <span class="hljs-keyword">if</span>(sum[i+s][j+s]-sum[i-s<span class="hljs-number">-1</span>][j+s]-sum[i+s][j-s<span class="hljs-number">-1</span>]+sum[i-s<span class="hljs-number">-1</span>][j-s<span class="hljs-number">-1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0x0</span>;      <span class="hljs-keyword">return</span> <span class="hljs-number">0xff</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getsize</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;j)</span> </span>&#123;      <span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>,r=n/<span class="hljs-number">2</span>,mid,ans=<span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span>(l&lt;=r) &#123;          mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;          <span class="hljs-keyword">if</span>(!~check(i,j,mid)) ans=mid,l=mid+<span class="hljs-number">1</span>;          <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;      &#125;      <span class="hljs-keyword">return</span> ans*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=n;i++)          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j(<span class="hljs-number">1</span>);j&lt;=n;j++)              sum[i][j]=sum[i][j<span class="hljs-number">-1</span>]+sum[i<span class="hljs-number">-1</span>][j]-sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+(<span class="hljs-built_in">map</span>[i][j]==<span class="hljs-string">&#x27;#&#x27;</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=n;i++)          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j(<span class="hljs-number">1</span>);j&lt;=n;j++) &#123;              <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[i][j]==<span class="hljs-string">&#x27;.&#x27;</span>)                  maxsize[i][j]=getsize(i,j);              <span class="hljs-keyword">else</span> maxsize[i][j]=<span class="hljs-number">-1</span>;          &#125;  &#125;&#125;</code></pre><h2 id="part2-缩点并连边"><a href="#part2-缩点并连边" class="headerlink" title="part2 缩点并连边"></a>part2 缩点并连边</h2></li><li><p>将MaxSize相同的点缩在一起，可以使用bfs或者并查集。我这里使用的是bfs。</p></li><li>连边时设$u&lt;v$，先加入要求生成树的图里。注意要判重，我这里使用的是<code>unordered_map</code>。</li><li>复杂度$O(n^2)$，将<code>unordered_map</code>的每次操作当成常数级别。</li></ul><p>代码：</p><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> BuildGraph &#123;    <span class="hljs-keyword">int</span> belong[maxn][maxn],cnt;<span class="hljs-comment">//联通块编号</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dx[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> dy[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-keyword">using</span> DealMatrix::maxsize;    <span class="hljs-keyword">char</span> vis[maxn][maxn];    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;i,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;j,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;col)</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; &gt; q;        vis[i][j]=<span class="hljs-number">0xff</span>;belong[i][j]=col;        q.push(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">make_pair</span>(i,j));        <span class="hljs-keyword">while</span>(!q.empty()) &#123;            <span class="hljs-keyword">int</span> x=q.front().first;            <span class="hljs-keyword">int</span> y=q.front().second;            q.pop();            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k(<span class="hljs-number">0</span>);k&lt;<span class="hljs-number">4</span>;k++) &#123;                <span class="hljs-keyword">int</span> nx=x+dx[k],ny=y+dy[k];                <span class="hljs-keyword">if</span>(nx&lt;<span class="hljs-number">1</span>||ny&lt;<span class="hljs-number">1</span>||nx&gt;n||ny&gt;n||maxsize[nx][ny]!=maxsize[i][j]||!~vis[nx][ny])                    <span class="hljs-keyword">continue</span>;                vis[nx][ny]=<span class="hljs-number">0xff</span>;                belong[nx][ny]=col;                q.push(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">make_pair</span>(nx,ny));            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">static</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt; <span class="hljs-keyword">int</span>,<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">char</span>&gt; &gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j(<span class="hljs-number">1</span>);j&lt;=n;j++)                <span class="hljs-keyword">if</span>(~vis[i][j]&amp;&amp;~maxsize[i][j])                    Search(i,j,++cnt);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=n;i++)            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j(<span class="hljs-number">1</span>);j&lt;=n;j++) &#123;                <span class="hljs-keyword">if</span>(!~maxsize[i][j]) <span class="hljs-keyword">continue</span>;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k(<span class="hljs-number">0</span>);k&lt;<span class="hljs-number">4</span>;k++) &#123;                    <span class="hljs-keyword">int</span> x=i+dx[k],y=j+dy[k];                    <span class="hljs-keyword">int</span> p=belong[i][j],q=belong[x][y];                    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">1</span>||y&lt;<span class="hljs-number">1</span>||x&gt;n||y&gt;n||!q||p==q) <span class="hljs-keyword">continue</span>;                    <span class="hljs-keyword">if</span>(p&gt;q) swap(p,q);                    <span class="hljs-keyword">if</span>(!~s[p][q]) <span class="hljs-keyword">continue</span>;                    s[p][q]=<span class="hljs-number">0xff</span>;                    Graph_1::e[++Graph_1::m]=Graph_1::Edge(p,q,min(maxsize[i][j],maxsize[x][y]));                &#125;            &#125;        N=cnt;        Graph_1::Kruscal();    &#125;&#125;</code></pre><h2 id="part3-求出最大生成树"><a href="#part3-求出最大生成树" class="headerlink" title="part3 求出最大生成树"></a>part3 求出最大生成树</h2><p>这个没什么说的。并查集我使用的是路径压缩+按秩合并版本，复杂度最优。复杂度$O(m\alpha(n^2))$，其中$m$为边数。</p><p>代码：</p><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> Graph_1 &#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>        <span class="hljs-keyword">int</span> u,v,w;        Edge(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;w)            :u(u),v(v),w(w) &#123;&#125;        Edge() &#123;&#125;    &#125;e[maxm&lt;&lt;<span class="hljs-number">2</span>];    <span class="hljs-keyword">int</span> m;<span class="hljs-keyword">char</span> InTree[maxm&lt;&lt;<span class="hljs-number">2</span>];    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Compare</span> &#123;</span>        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> Edge &amp;a,<span class="hljs-keyword">const</span> Edge &amp;b)</span> </span>&#123;            <span class="hljs-keyword">return</span> a.w&lt;b.w;        &#125;    &#125;cmp;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UnoinFindSet</span> &#123;</span>        <span class="hljs-keyword">int</span> fa[maxm],rank[maxm];        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=N;i++) fa[i]=i,rank[i]=<span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x)</span> </span>&#123;            <span class="hljs-keyword">return</span> (x == fa[x]) ? x : (fa[x] = Find( fa[x] ));        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v)</span> </span>&#123;            int x(Find(u)),y(Find(v));            <span class="hljs-keyword">if</span>(x!=y) &#123;                <span class="hljs-keyword">if</span>(rank[x]&lt;rank[y]) fa[x]=y,rank[y]=max(rank[y],rank[x]+<span class="hljs-number">1</span>);                <span class="hljs-keyword">else</span> fa[y]=x,rank[x]=max(rank[x],rank[y]+<span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Same</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v)</span> </span>&#123;            <span class="hljs-keyword">return</span> Find(u)==Find(v);        &#125;    &#125;U;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Kruscal</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">std</span>::sort(e+<span class="hljs-number">1</span>,e+<span class="hljs-number">1</span>+m,cmp);        U.Init();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=m;i++) &#123;            <span class="hljs-keyword">if</span>(U.Same(e[i].u,e[i].v)) <span class="hljs-keyword">continue</span>;            U.Merge(e[i].u,e[i].v);            InTree[i]=<span class="hljs-number">0xff</span>;        &#125;    &#125;&#125;</code></pre><h2 id="part4-树上快速查询"><a href="#part4-树上快速查询" class="headerlink" title="part4 树上快速查询"></a>part4 树上快速查询</h2><ul><li>这里方法很多，可以倍增，树剖<del>还有LCT</del>。这里采用的是树剖+ST表。复杂度预处理$n^2logn$，每次查询$logn$。</li><li>注意求出的生成树可能是森林。</li><li>另外，因为前面把点权转化为边权，这里又把边权转化为点权处理，所以树剖询问时不能加上lca的贡献。</li></ul><p>代码：</p><pre><code class="hljs cpp"><span class="hljs-comment">// 第三部分树剖最小值，在最小生成树上查询瓶颈路。注意，可能是一个森林</span><span class="hljs-keyword">namespace</span> Tree &#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span>        <span class="hljs-keyword">int</span> v,next,w;        Edge(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;next,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;w)            :v(v),next(next),w(w) &#123;&#125;        Edge() &#123;&#125;    &#125;e[maxm&lt;&lt;<span class="hljs-number">1</span>];    <span class="hljs-keyword">int</span> head[maxm],cnt;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;w)</span> </span>&#123;        e[++cnt]=Edge(v,head[u],w);        head[u]=cnt;    &#125;    <span class="hljs-keyword">int</span> val[maxm];<span class="hljs-comment">//边权转化为点权</span>    <span class="hljs-keyword">namespace</span> STTable &#123;        <span class="hljs-keyword">int</span> f[maxm][<span class="hljs-number">21</span>],Log[maxm];        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> f);            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">0</span>),w(<span class="hljs-number">1</span>);w&lt;=N;i++,w&lt;&lt;=<span class="hljs-number">1</span>) Log[w]=i;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=N;i++) <span class="hljs-keyword">if</span>(!Log[i]) Log[i]=Log[i<span class="hljs-number">-1</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=N;i++)                f[i][<span class="hljs-number">0</span>]=val[i];            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j(<span class="hljs-number">1</span>);j&lt;<span class="hljs-number">21</span>;j++)                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=N;i++)                    <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>+(<span class="hljs-number">1</span>&lt;&lt;j)<span class="hljs-number">-1</span>&lt;=N)                        f[i][j]=min(f[i][j<span class="hljs-number">-1</span>],f[i+(<span class="hljs-number">1</span>&lt;&lt;(j<span class="hljs-number">-1</span>))][j<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">QueryMin</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;l,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r)</span> </span>&#123;            <span class="hljs-keyword">if</span>(l&gt;r) <span class="hljs-keyword">return</span> inf;            <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">o</span><span class="hljs-params">(Log[r-l+<span class="hljs-number">1</span>])</span></span>;            <span class="hljs-keyword">return</span> min(f[l][o],f[r-(<span class="hljs-number">1</span>&lt;&lt;o)+<span class="hljs-number">1</span>][o]);        &#125;    &#125;    <span class="hljs-keyword">int</span> size[maxm],fa[maxm],son[maxm],w[maxm],depth[maxm],belong[maxm],Cnt_Tree;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;u)</span> </span>&#123;        belong[u]=Cnt_Tree;        size[u]=<span class="hljs-number">1</span>;depth[u]=depth[fa[u]]+<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(head[u]);i;i=e[i].next) &#123;            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v=e[i].v;            <span class="hljs-keyword">if</span>(v==fa[u]) <span class="hljs-keyword">continue</span>;            fa[v]=u;            dfs1(v);            size[u]+=size[v];            <span class="hljs-keyword">if</span>(size[v]&gt;size[son[u]]) son[u]=v,w[u]=e[i].w;        &#125;    &#125;    <span class="hljs-keyword">int</span> top[maxm],dfn[maxm],stamp;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;anc)</span> </span>&#123;        dfn[u]=++stamp;        top[u]=anc;        <span class="hljs-keyword">if</span>(son[u]) dfs2(son[u],anc),val[dfn[son[u]]]=w[u];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(head[u]);i;i=e[i].next) &#123;            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v=e[i].v;            <span class="hljs-keyword">if</span>(v==fa[u]||v==son[u]) <span class="hljs-keyword">continue</span>;            dfs2(v,v);val[dfn[v]]=e[i].w;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">GetMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u,<span class="hljs-keyword">int</span> v)</span> </span>&#123;        <span class="hljs-keyword">int</span> ans=inf;        <span class="hljs-keyword">while</span>(top[u]!=top[v]) &#123;            <span class="hljs-keyword">if</span>(depth[top[u]]&lt;depth[top[v]]) swap(u,v);            ans=min(ans,STTable::QueryMin(dfn[top[u]],dfn[u]));            u=fa[top[u]];        &#125;        <span class="hljs-keyword">if</span>(depth[u]&gt;depth[v]) swap(u,v);        ans=min(ans,STTable::QueryMin(dfn[u]+<span class="hljs-number">1</span>,dfn[v]));        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=Graph_1::m;i++)            <span class="hljs-keyword">if</span>(!~Graph_1::InTree[i]) &#123;                AddEdge(Graph_1::e[i].u,Graph_1::e[i].v,Graph_1::e[i].w);                AddEdge(Graph_1::e[i].v,Graph_1::e[i].u,Graph_1::e[i].w);            &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=N;i++)            <span class="hljs-keyword">if</span>(!dfn[i]) &#123;                Cnt_Tree++;                dfs1(i);                dfs2(i,i);            &#125;        STTable::Init();    &#125;&#125;</code></pre><h2 id="part5-处理询问"><a href="#part5-处理询问" class="headerlink" title="part5 处理询问"></a>part5 处理询问</h2><p>注意亿点细节。例如，不在一棵树上以及所询问的点就是障碍时，返回无解。</p><p>代码：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Query</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;y1,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;x2,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;y2)</span> </span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">map</span>[x1][y1]==<span class="hljs-string">&#x27;#&#x27;</span>||<span class="hljs-built_in">map</span>[x2][y2]==<span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> u=BuildGraph::belong[x1][y1],v=BuildGraph::belong[x2][y2];    <span class="hljs-keyword">if</span>(u==v) <span class="hljs-keyword">return</span> DealMatrix::maxsize[x1][y1];    <span class="hljs-keyword">if</span>(Tree::belong[u]!=Tree::belong[v]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> ans=Tree::GetMin(u,v);    <span class="hljs-keyword">if</span>(ans==inf) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>总复杂度$O((n^2+q)logn+m\alpha(n^2))$。可以将$m$看作是$n^2$级别，但实际远远要小。</p><p>至此，此题终于做完了。我的代码共354行，算得上是我打过的最长的代码了。<del>还不是因为加了个七十多行的快速读写</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡常技巧-快速IO</title>
    <link href="/2020/09/10/%E5%8D%A1%E5%B8%B8%E6%8A%80%E5%B7%A7-%E5%BF%AB%E9%80%9FIO/"/>
    <url>/2020/09/10/%E5%8D%A1%E5%B8%B8%E6%8A%80%E5%B7%A7-%E5%BF%AB%E9%80%9FIO/</url>
    
    <content type="html"><![CDATA[<p>在$OI$中，卡常是一门奇怪又必备的技巧，在某些毒瘤题<del>如Ynoi</del>中需要用到许多卡常技巧才能卡入时限。这里给出我自己的快速$IO$卡常代码。</p><h1 id="一、快速读入"><a href="#一、快速读入" class="headerlink" title="一、快速读入"></a>一、快速读入</h1><h2 id="1、带符号整形"><a href="#1、带符号整形" class="headerlink" title="1、带符号整形"></a>1、带符号整形</h2><p>最简单基础的快读。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span> </span>&#123;    x=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> k=<span class="hljs-literal">false</span>;<span class="hljs-keyword">char</span> c=getc();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;k|=(c==<span class="hljs-string">&#x27;-&#x27;</span>);c=getc();<span class="hljs-keyword">if</span>(c==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) &#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>);c=getc();&#125;    x*=(k?<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>或换个写法</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;x)</span> </span>&#123;    x=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> k=<span class="hljs-literal">false</span>;<span class="hljs-keyword">char</span> c=getc();    <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=getc()) &#123;k|=(c==<span class="hljs-string">&#x27;-&#x27;</span>);<span class="hljs-keyword">if</span>(c==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);c=getc()) &#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>);&#125;    x*=(k?<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>其中<code>getc</code>为读入一个字符的函数，函数返回值为是否读到数。在对$x$的位运算处，不排除有更优秀的写法。</p><h2 id="2、单个字符"><a href="#2、单个字符" class="headerlink" title="2、单个字符"></a>2、单个字符</h2><p>如果只是要求读入字符，可以直接</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;    <span class="hljs-keyword">return</span> (c=getc())!=EOF;&#125;</code></pre><p>如果对读入的字符有要求，如必须是字母或数字等，可以使用<code>cctype</code>库中函数来判断读入。以读入非空字符为例：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;    <span class="hljs-keyword">while</span>(c=getc(),<span class="hljs-built_in">isspace</span>(c));    <span class="hljs-keyword">return</span> c!=EOF;&#125;</code></pre><p>注意<code>EOF</code>标识符在<code>isspace</code>中返回真。</p><h2 id="3、字符串"><a href="#3、字符串" class="headerlink" title="3、字符串"></a>3、字符串</h2><p>采用和<code>scanf</code>一样的读入方式，即在读入空字符时停止。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;    *s=getc();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*s)) &#123;*s=getc();<span class="hljs-keyword">if</span>(*s==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isspace</span>(*s)&amp;&amp;*s!=EOF) &#123;s++;*s=getc();&#125;    *s=<span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="4、浮点数"><a href="#4、浮点数" class="headerlink" title="4、浮点数"></a>4、浮点数</h2><p>因为浮点数精度问题，它的手动读入并不好写，并且出错率或误差率远远大于用<code>scanf</code>或<code>std::cin</code>读入。</p><p>这里给出我的一个浮点数读入实现，仅供参考。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">double</span> &amp;x)</span> </span>&#123;    x=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> k=<span class="hljs-literal">false</span>;<span class="hljs-keyword">double</span> d=<span class="hljs-number">1</span>;<span class="hljs-keyword">char</span> c=getc();    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;k|=(c==<span class="hljs-string">&#x27;-&#x27;</span>);c=getc();<span class="hljs-keyword">if</span>(c==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) &#123;x=x*<span class="hljs-number">10</span>+(c^<span class="hljs-number">48</span>);c=getc();&#125;    <span class="hljs-keyword">if</span>(c!=<span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    c=getc();    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) &#123;d/=<span class="hljs-number">10.0</span>;x+=d*(c^<span class="hljs-number">48</span>);c=getc();&#125;    x*=(k?<span class="hljs-number">-1.0</span>:<span class="hljs-number">1.0</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><p>在读入小数部分时<code>d</code>临时保存当前位。</p><h1 id="二、快速输出"><a href="#二、快速输出" class="headerlink" title="二、快速输出"></a>二、快速输出</h1><h2 id="1、带符号整形-1"><a href="#1、带符号整形-1" class="headerlink" title="1、带符号整形"></a>1、带符号整形</h2><p>一般有递归和非递归两种写法。这里采用非递归写法，因为时间效率较高。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> p=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) &#123;putc(<span class="hljs-string">&#x27;-&#x27;</span>);x=-x;&#125;    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) putc(<span class="hljs-string">&#x27;0&#x27;</span>);    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(;x;x/=<span class="hljs-number">10</span>) buf[++p]=x%<span class="hljs-number">10</span>+<span class="hljs-number">48</span>;    <span class="hljs-keyword">for</span>(;p!=<span class="hljs-number">-1</span>;p--) putc(buf[p]);&#125;</code></pre><p><code>putc</code>为输出单个字符函数，<code>buf</code>为缓存区，一般开到<code>20</code>即可。</p><h2 id="2、单个字符-1"><a href="#2、单个字符-1" class="headerlink" title="2、单个字符"></a>2、单个字符</h2><p>没什么说的，就直接输出。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;putc(c);&#125;</code></pre><h2 id="3、字符串-1"><a href="#3、字符串-1" class="headerlink" title="3、字符串"></a>3、字符串</h2><p>因为传参的最佳匹配原因，字符串要分两种重载方式。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;    <span class="hljs-keyword">while</span>(*s!=<span class="hljs-string">&#x27;\0&#x27;</span>) putc(*s),s++;&#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span> </span>&#123;    <span class="hljs-keyword">while</span>(*s!=<span class="hljs-string">&#x27;\0&#x27;</span>) putc(*s),s++;&#125;</code></pre><p>当传入<code>char *s</code>时，最佳匹配是<code>template&lt;tyename Type&gt; write(Type x)</code>，而不是<code>write(const char *s)</code>。更佳的匹配是<code>write(char *s)</code>。所以要写两个重载。</p><h2 id="4、浮点数-1"><a href="#4、浮点数-1" class="headerlink" title="4、浮点数"></a>4、浮点数</h2><p>浮点数的快输由于精度以及四舍五入的问题，比快读更加难写并且容易出锅。</p><p>这里给出一种实现。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">35</span>];<span class="hljs-keyword">int</span> p=<span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0.0</span>) putc(<span class="hljs-string">&#x27;-&#x27;</span>),x*=<span class="hljs-number">-1.0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=pre;i++) x*=<span class="hljs-number">10.0</span>;    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-title">y</span><span class="hljs-params">(round(x))</span></span>;    <span class="hljs-keyword">for</span>(;y;y/=<span class="hljs-number">10</span>) buf[++p]=y%<span class="hljs-number">10</span>+<span class="hljs-number">48</span>;    <span class="hljs-keyword">if</span>(p&lt;pre) &#123;        putc(<span class="hljs-string">&#x27;0&#x27;</span>);putc(<span class="hljs-string">&#x27;.&#x27;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i(<span class="hljs-number">1</span>);i&lt;=pre-p<span class="hljs-number">-1</span>;i++) putc(<span class="hljs-string">&#x27;0&#x27;</span>);    &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">while</span>(p+<span class="hljs-number">1</span>&gt;pre) putc(buf[p--]);        putc(<span class="hljs-string">&#x27;.&#x27;</span>);    &#125;    <span class="hljs-keyword">for</span>(;p!=<span class="hljs-number">-1</span>;p--) putc(buf[p]);&#125;</code></pre><p><code>pre</code>为保留小数点后几位，<code>round</code>为<code>cmath</code>库里的四舍五入到整数的函数。</p><h1 id="三、块读写优化"><a href="#三、块读写优化" class="headerlink" title="三、块读写优化"></a>三、块读写优化</h1><p>有了上述对具体数据类型的处理优化之后，速度瓶颈变为了输入输出字符的<code>getc()</code>，<code>putc()</code>函数。调用<code>cstdio</code>库中的<code>getchar()</code>和<code>putchar()</code>函数过于慢，解决方法有使用<code>streambuf</code>或<code>fread</code>和<code>fwrite</code>。这里采用的后者。因为其提速原理为整块的输入输出操作，所以称为块读写。</p><h2 id="１、fread"><a href="#１、fread" class="headerlink" title="１、ｆｒｅａｄ"></a>１、ｆｒｅａｄ</h2><p>直接给出<code>getc()</code>函数</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">getc</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>],*p1=buf,*p2=buf;    <span class="hljs-keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>,<span class="hljs-built_in">stdin</span>),p1==p2)?EOF:*p1++;&#125;</code></pre><p><code>static</code>修饰符保证了缓存数组在函数每次返回后不变，以及外部函数无法访问。</p><p>此处三元运算符应用逻辑运算符的短路原理等，简介而精炼。建议仔细品读以理解其意思。</p><h2 id="２、fwrite"><a href="#２、fwrite" class="headerlink" title="２、ｆｗｒｉｔｅ"></a>２、ｆｗｒｉｔｅ</h2><p><code>putc()</code>函数为了在适当时期调用稍微繁琐一些。</p><pre><code class="hljs cpp"><span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>];<span class="hljs-keyword">int</span> p1=<span class="hljs-number">-1</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p2=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>)<span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;    fwrite(buf,<span class="hljs-number">1</span>,p1+<span class="hljs-number">1</span>,<span class="hljs-built_in">stdout</span>);    p1=<span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;    <span class="hljs-keyword">if</span>(p1==p2) flush();    buf[++p1]=c;&#125;</code></pre><p>在主函数末尾调用<code>flush()</code>以输出。在缓存区满时也会自动调用。</p><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>我写出了快速读写的函数版本和类版本，可以适当时候选用用起来爽的版本。此处附带了库函数的部分替代函数。</p><p>函数版本：</p><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> quick &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tp template<span class="hljs-meta-string">&lt;typename Type&gt;</span></span>    <span class="hljs-keyword">namespace</span> in &#123;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">getc</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>],*p1=buf,*p2=buf;            <span class="hljs-keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>,<span class="hljs-built_in">stdin</span>),p1==p2)?EOF:*p1++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;            *s=getc();            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*s)) &#123;*s=getc();<span class="hljs-keyword">if</span>(*s==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isspace</span>(*s)&amp;&amp;*s!=EOF) &#123;s++;*s=getc();&#125;            *s=<span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(Type &amp;x)</span> </span>&#123;            x=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> k=<span class="hljs-literal">false</span>;<span class="hljs-keyword">char</span> c=getc();            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;k|=(c==<span class="hljs-string">&#x27;-&#x27;</span>);c=getc();<span class="hljs-keyword">if</span>(c==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) &#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>);c=getc();&#125;            x*=(k?<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type,<span class="hljs-keyword">typename</span>... Args&gt;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(Type &amp;t,Args &amp;...args)</span> </span>&#123;            <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;            res+=read(t);res+=read(args...);            <span class="hljs-keyword">return</span> res;        &#125;    &#125;    <span class="hljs-keyword">using</span> in::read;    <span class="hljs-keyword">namespace</span> out &#123;        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>];<span class="hljs-keyword">int</span> p1=<span class="hljs-number">-1</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p2=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>)<span class="hljs-number">-1</span>;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;            fwrite(buf,<span class="hljs-number">1</span>,p1+<span class="hljs-number">1</span>,<span class="hljs-built_in">stdout</span>);            p1=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;            <span class="hljs-keyword">if</span>(p1==p2) flush();            buf[++p1]=c;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;            <span class="hljs-keyword">while</span>(*s!=<span class="hljs-string">&#x27;\0&#x27;</span>) putc(*s),s++;        &#125;        <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Type x)</span> </span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> p=<span class="hljs-number">-1</span>;            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) &#123;putc(<span class="hljs-string">&#x27;-&#x27;</span>);x=-x;&#125;            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) putc(<span class="hljs-string">&#x27;0&#x27;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(;x;x/=<span class="hljs-number">10</span>) buf[++p]=x%<span class="hljs-number">10</span>+<span class="hljs-number">48</span>;            <span class="hljs-keyword">for</span>(;p!=<span class="hljs-number">-1</span>;p--) putc(buf[p]);        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;putc(c);&#125;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type,<span class="hljs-keyword">typename</span>... Args&gt;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Type t,Args ...args)</span> </span>&#123;            write(t);write(args...);        &#125;    &#125;    <span class="hljs-keyword">using</span> out::write;    <span class="hljs-keyword">using</span> out::flush;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type a,<span class="hljs-keyword">const</span> Type b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> b;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type a,<span class="hljs-keyword">const</span> Type b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> a;        <span class="hljs-keyword">return</span> b;    &#125;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Type &amp;a,Type &amp;b)</span> </span>&#123;        a^=b^=a^=b;    &#125;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type a)</span> </span>&#123;        <span class="hljs-keyword">return</span> a&gt;=<span class="hljs-number">0</span>?a:-a;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> tp</span>&#125;</code></pre><p>因为是不定参，调用时可以使用像<code>read(a,b,c,d)</code>这样的写法。</p><p>类版本：</p><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> Quick &#123;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InStream</span> &#123;</span>    <span class="hljs-keyword">private</span>:        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>],*p1,*p2,failed;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">getc</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>,<span class="hljs-built_in">stdin</span>),p1==p2)?EOF:*p1++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Type&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(Type &amp;x)</span> </span>&#123;            <span class="hljs-keyword">bool</span> k=<span class="hljs-literal">false</span>;<span class="hljs-keyword">char</span> c=getc();            <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isdigit</span>(c);c=getc()) &#123;k|=(c==<span class="hljs-string">&#x27;-&#x27;</span>);<span class="hljs-keyword">if</span>(c==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;            x=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isdigit</span>(c);c=getc()) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>);            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;            *s=getc();            <span class="hljs-keyword">for</span>(;<span class="hljs-built_in">isspace</span>(*s)||*s==EOF;*s=getc()) <span class="hljs-keyword">if</span>(*s==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(;!<span class="hljs-built_in">isspace</span>(*s)&amp;&amp;*s!=EOF;*s=getc()) s++;            *s=<span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    <span class="hljs-keyword">public</span>:        <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;            <span class="hljs-keyword">return</span> ~failed;        &#125;        InStream() &#123;p1=p2=buf;failed=<span class="hljs-number">0x00</span>;&#125;        ~InStream() &#123;&#125;        <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">InStream</span>&amp; <span class="hljs-title">operator</span> &gt;&gt; (<span class="hljs-title">Type</span> &amp;&amp;<span class="hljs-title">x</span>) &#123;</span>            <span class="hljs-keyword">if</span>(read(x)) failed=<span class="hljs-number">0x00</span>;            <span class="hljs-keyword">else</span> failed=<span class="hljs-number">0xff</span>;            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        &#125;    &#125;<span class="hljs-built_in">cin</span>;    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OutStream</span> &#123;</span>    <span class="hljs-keyword">private</span>:        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>];<span class="hljs-keyword">int</span> p1;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p2=<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;            fwrite(buf,<span class="hljs-number">1</span>,p1,<span class="hljs-built_in">stdout</span>);            p1=<span class="hljs-number">0</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;            <span class="hljs-keyword">if</span>(p1==p2) flush();            buf[p1++]=c;        &#125;        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Type&gt; <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Type x)</span> </span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">25</span>];<span class="hljs-keyword">int</span> p=<span class="hljs-number">-1</span>;            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) &#123;x*=<span class="hljs-number">-1</span>;putc(<span class="hljs-string">&#x27;-&#x27;</span>);&#125;            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) putc(<span class="hljs-string">&#x27;0&#x27;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(;x;x/=<span class="hljs-number">10</span>) buf[++p]=x%<span class="hljs-number">10</span>+<span class="hljs-number">48</span>;            <span class="hljs-keyword">while</span>(~p) putc(buf[p--]);        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;            <span class="hljs-keyword">for</span>(;*s;s++) putc(*s);        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span> </span>&#123;            <span class="hljs-keyword">for</span>(;*s;s++) putc(*s);        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;putc(c);&#125;    <span class="hljs-keyword">public</span>:        OutStream() &#123;p1=<span class="hljs-number">0</span>;&#125;        ~OutStream() &#123;flush();&#125;        <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span>&gt; <span class="hljs-title">OutStream</span>&amp; <span class="hljs-title">operator</span> &lt;&lt; (const Type &amp;x) &#123;</span><span class="hljs-class">            write(x);return *this;</span><span class="hljs-class">        &#125;</span><span class="hljs-class">    &#125;cout;</span><span class="hljs-class">    const char endl(&#x27;\n&#x27;);</span><span class="hljs-class"></span><span class="hljs-class">    template&lt;class Type&gt; inline Type max(const Type &amp;a,const Type &amp;b) &#123;</span><span class="hljs-class">        if(a&lt;b) return b;</span><span class="hljs-class">        return a;</span><span class="hljs-class">    &#125;</span><span class="hljs-class">    template&lt;class Type&gt; inline Type min(const Type &amp;a,const Type &amp;b) &#123;</span><span class="hljs-class">        if(a&lt;b) return a;</span><span class="hljs-class">        return b;</span><span class="hljs-class">    &#125;</span><span class="hljs-class">    template&lt;class Type&gt; inline void swap(Type &amp;a,Type &amp;b) &#123;</span><span class="hljs-class">        static Type tmp;</span><span class="hljs-class">        tmp=a;a=b;b=tmp;</span><span class="hljs-class">    &#125;</span><span class="hljs-class">    template&lt;class Type&gt; inline Type abs(const Type &amp;a) &#123;</span><span class="hljs-class">        return a&gt;=0?a:-a;</span><span class="hljs-class">    &#125;</span><span class="hljs-class"></span><span class="hljs-class">&#125;</span></code></pre><p>类版本可以使用和<code>std::cin</code>和<code>std::cout</code>相同的方法调用。比如，可以<code>while(Quick::cin&gt;&gt;a)</code>。</p><p>注意类版本主函数末尾不需要调用<code>flush()</code>，因为在销毁内存时自动调用了。另外，为了使函数版本也实现这种功能，也可以封装到类里，并不定参重载<code>()</code>运算符。</p>]]></content>
    
    
    
    <tags>
      
      <tag>卡常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>做题记录（三）</title>
    <link href="/2020/09/08/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/09/08/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="POI2011-ROT-Tree-Rotations"><a href="#POI2011-ROT-Tree-Rotations" class="headerlink" title="[POI2011]ROT-Tree Rotations"></a><a href="https://www.luogu.com.cn/problem/P3521">[POI2011]ROT-Tree Rotations</a></h1><p>树上线段树合并。考虑在每个叶节点建一颗权值线段树，然后向上合并。</p><p>因为交换子树只会影响到跨越左右子树的逆序对数，所以考虑决策是否交换。</p><p>在合并左右子树的权值线段树时，设左子树当前节点为$a$，右子树的当前节点为$b$，$lc,rc$分别为权值线段树中的左右儿子。则不交换在当前值域产生的逆序对数为$sum[rc[a]]<em>sum[lc[b]]$，交换在当前值域产生的逆序对数为$sum[lc[a]]</em>sum[rc[b]]$。取最大值统计即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>做题记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学杂项</title>
    <link href="/2020/09/08/math1/"/>
    <url>/2020/09/08/math1/</url>
    
    <content type="html"><![CDATA[<h2 id="一-组合数公式"><a href="#一-组合数公式" class="headerlink" title="一. 组合数公式"></a>一. 组合数公式</h2><script type="math/tex; mode=display">C^n_m = \frac{m!}{n!(m-n)!} , n \geq m</script><p>那么可以在$O(n^2)$的复杂度上递推出组合数<br><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(C,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> C);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) &#123;    C[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)        C[i][j]=C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+C[i<span class="hljs-number">-1</span>][j];&#125;</code></pre><br>由组合数定义易证得</p><script type="math/tex; mode=display">C^n_m = \frac{m-n+1}{n} C^{n-1}_m</script><p>于是也可以在$O(n)$的复杂度上递推出组合数<br><pre><code class="hljs cpp">C[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) C[i]=C[i<span class="hljs-number">-1</span>]*(n-i+<span class="hljs-number">1</span>)/i;<span class="hljs-comment">//先乘后除，避免小数，但要考虑溢出的情况</span></code></pre><br>注意，第二种方法因为有除法，所以不能取模。在需要给组合数取模时，应使用第一种方法。</p><h2 id="二-二项式定理"><a href="#二-二项式定理" class="headerlink" title="二. 二项式定理"></a>二. 二项式定理</h2><p> 对于一个多项式$(a+b)^n$，其展开后的系数构成杨辉三角。即</p><script type="math/tex; mode=display">(a+b)^n = \sum_{r=0}^n C^r_n a^{n-r} b^r</script><p> 所以，可以通过递推组合数来求解杨辉三角即多项式系数。<br> 例题：<a href="https://www.luogu.com.cn/problem/P1313">洛谷1313 计算系数</a> <a href="https://www.luogu.com.cn/problem/P2822">洛谷2822 组合数问题</a><br>难题：<a href="https://www.luogu.com.cn/problem/UVA1635">UVa1635 Irrelevant Elements</a></p><h2 id="三-卢卡斯定理"><a href="#三-卢卡斯定理" class="headerlink" title="三. 卢卡斯定理"></a>三. 卢卡斯定理</h2><p>数论中Lucas定理描述为：<br>设p为素数,$a,b\in N^*$,并且</p><script type="math/tex; mode=display">a=a_kp^k+a_{k-1}p^{k-1}+ \cdots +a_1p+a_0,\\</script><script type="math/tex; mode=display">b=b_kp^k+b_{k-1}p^{k-1}+ \cdots +b_1p+b_0,\\</script><p>这里$0\leq a<em>i,b_i \leq p-1$都是整数,$i=0,1,2,…,k.$.那么：<br>$ C^b_a \equiv C^{b_k}</em>{a<em>k} \cdot C^{b</em>{k-1}}<em>{a</em>{k-1}} \cdot \cdots \cdot C^{b<em>0}</em>{a_0} (mod \: p) $<br>证明略。</p><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><p>求$C^m_n mod \: k$,其中$n,m\leq 10^{10}$,k是素数且较小.</p><h1 id="四-容斥原理"><a href="#四-容斥原理" class="headerlink" title="四. 容斥原理"></a>四. 容斥原理</h1><p>  在计数时，必须注意无一重复，无一遗漏。为了使重叠部分不被重复计算，人们研究出一种新的计数方法，这种方法的基本思想是：<strong>先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。</strong> 即：</p><script type="math/tex; mode=display">\left| A_1 \cup A_2 \cup \cdots \cup A_m \right| = \sum_{i=1}^m \left| a_i \right| - \sum_{j=i+1}^m \left| A_i \cup A_j \right| + \sum_{k=j+1}^m \left| A_i \cup A_j \cup A_k \right| - \cdots + \left( -1^{m-1} \right)\left| A_1 \cup A_2 \cup A_3 \cup \cdots \cup A_m \right|</script><h1 id="五-欧拉函数"><a href="#五-欧拉函数" class="headerlink" title="五. 欧拉函数"></a>五. 欧拉函数</h1><p> 定义：小于或等于n的正整数中与n互质的数的数目, 记作$\varphi \left(n\right)$.定义式 : </p><script type="math/tex; mode=display">\varphi \left(n\right) = \sum_{S \in \{p_1p_2p_3 \cdots p_n\}} (-1)^{|S|} \frac{n}{\prod_{p_i \in S} p_i}</script><p>可乘性：$\varphi \left(p \cdot q\right)=\varphi \left(p\right) \cdot \varphi \left(q\right)$, 当且仅当$p,q$互质</p><p>计算式：$\varphi \left(n\right) = n \cdot \prod_{p|n} (1-\frac{1}{p})$</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">euler_varphi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> ans=n,m=<span class="hljs-built_in">sqrt</span>(n);    <span class="hljs-keyword">for</span>(R i=<span class="hljs-number">2</span>;i&lt;=m;i++) &#123;        <span class="hljs-keyword">if</span>(n%i) <span class="hljs-keyword">continue</span>;        ans=ans/i*(i<span class="hljs-number">-1</span>);        <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) n/=i;    &#125;    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) ans=ans/n*(n<span class="hljs-number">-1</span>);    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>线性递推：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get_varphi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    varphi[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">2</span>);i&lt;=n;i++) &#123;        <span class="hljs-keyword">if</span>(varphi[i]) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">for</span>(R j(i);j&lt;=n;j+=i) &#123;            <span class="hljs-keyword">if</span>(!varphi[j]) varphi[j]=j;            varphi[j]=varphi[j]/i*(i<span class="hljs-number">-1</span>);        &#125;    &#125;&#125;</code></pre><h1 id="六-欧拉定理"><a href="#六-欧拉定理" class="headerlink" title="六. 欧拉定理"></a>六. 欧拉定理</h1><script type="math/tex; mode=display">a^c \equiv \begin{cases}a^{c \bmod \varphi \left(m\right) }  & gcd\left(a,m\right)=1 \\\\a^c & gcd\left(a,m\right)\neq 1 \pmod m , c<\varphi \left(m\right)  \\\\a^{\left(c \bmod \varphi \left(m\right)\right)+\varphi \left(m\right)} & gcd\left(a,m\right)\neq 1 \pmod m , c \geq \varphi \left(m\right)\end{cases}\pmod m</script><p>模版：<a href="https://www.luogu.com.cn/problem/P5091">洛谷P5091</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QT题单数学练习</title>
    <link href="/2020/09/08/MathPractice/"/>
    <url>/2020/09/08/MathPractice/</url>
    
    <content type="html"><![CDATA[<h1 id="GCD等于XOR-GCD-XOR"><a href="#GCD等于XOR-GCD-XOR" class="headerlink" title="GCD等于XOR GCD XOR"></a><a href="https://www.luogu.com.cn/problem/UVA12716">GCD等于XOR GCD XOR</a></h1><p>求</p><script type="math/tex; mode=display">\sum_{i=1}^n\sum_{j=i}^n\left[gcd(i,j)=i \operatorname{xor} j\right]</script><p>设</p><script type="math/tex; mode=display">\operatorname{gcd}(a,b)=a \operatorname{xor}b=c\quad (a\ge b)\\\\\Rightarrow \operatorname{gcd}(\frac{a}{c},\frac{b}{c})=1,\\</script><p>异或为不借位的减法，所以两数差一定不大于两数异或</p><script type="math/tex; mode=display">a-b\le c\quad,\\\\\Rightarrow \frac{a}{c}-\frac{b}{c}\le 1</script><p>综上，$a-b=a\operatorname{xor}b$。先枚举$a$的约数，再枚举$a$。预处理前缀和即可。</p><h1 id="Same-GCDs"><a href="#Same-GCDs" class="headerlink" title="Same GCDs"></a><a href="https://www.luogu.com.cn/problem/CF1295D">Same GCDs</a></h1><p>设$d=gcd(a,m)$，则</p><script type="math/tex; mode=display">gcd\left(\frac{a}{d},\frac{m}{d}\right)=gcd\left(\frac{a+x}{d},\frac{m}{d}\right)=1</script><p>得到</p><script type="math/tex; mode=display">\frac{a+x}{d} \perp \frac{m}{d} \Leftrightarrow \frac{x}{d} \perp \frac{m}{d}</script><p>所以$a$仅仅是将$[0,m-1]$的数进行了一段平移，答案为$\varphi\left(\frac{m}{d}\right)$</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>数学，练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-SAT</title>
    <link href="/2020/09/08/2-SAT/"/>
    <url>/2020/09/08/2-SAT/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4782">洛谷4782</a><br>题意：给定m个约束条件，形式为$x_i,x_j$，表示$x_i$为真/假或$x_j$为真/假，给每个变量赋值使得所有条件得到满足。</p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>将问题转化为图论问题。设$x$表示变量$x$取<code>false</code>，¬$x$表示变量$x$取<code>true</code>。建立$2 \times n$个点，设$x_i$对应点$i$，¬$x_i$对应点$i+n$，则连有向边的意义为若前者成立则后者必成立。利用给出条件连边建图：</p><div class="table-container"><table><thead><tr><th style="text-align:center">约束条件</th><th style="text-align:center">连边</th></tr></thead><tbody><tr><td style="text-align:center">$x_i$ or $x_j$</td><td style="text-align:center">$i+n \rightarrow j , j+n \rightarrow i$</td></tr><tr><td style="text-align:center">¬$x_i$ or $x_j$</td><td style="text-align:center">$i \rightarrow j , j+n \rightarrow i+n$</td></tr><tr><td style="text-align:center">$x_i$ or ¬$x_j$</td><td style="text-align:center">$i+n \rightarrow j+n , j \rightarrow i$</td></tr><tr><td style="text-align:center">¬$x_i$ or ¬$x_j$</td><td style="text-align:center">$i \rightarrow j+n , j \rightarrow i+n$</td></tr></tbody></table></div><p><strong>以一言以蔽之：对于每个约束，若其中一个变量不满足条件，则另一个必须满足。</strong><br>连边代码如下<del>位运算毒瘤</del>：<br><pre><code class="hljs cpp">AddEdge(u+n*(a^<span class="hljs-number">1</span>),v+n*(b&amp;<span class="hljs-number">1</span>));AddEdge(v+n*(b^<span class="hljs-number">1</span>),u+n*(a&amp;<span class="hljs-number">1</span>));</code></pre><br>接下来需要找出是否有可行解。可以发现，$i$是$j$的前驱当且仅当$i$点的取值条件成立时$j$点的取值条件成立（此处取值条件指点所指的变量为<code>true</code>或<code>false</code>），并且有$i$点的取值条件不成立时$j$点的取值条件不一定成立。显然，当$x_i$和¬$x_i$属于同一个强连通分量时，不存在可行解（存在互相矛盾）。因此，只要使用$tarjan$缩点，在每个强连通分量中看有没有$i$和$i+n$的点对即可实现。</p><p>代码如下：<br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs cpp"><span class="hljs-keyword">int</span> low[maxn&lt;&lt;<span class="hljs-number">1</span>],dfn[maxn&lt;&lt;<span class="hljs-number">1</span>],stamp,belong[maxn&lt;&lt;<span class="hljs-number">1</span>],cnt;<br><span class="hljs-keyword">int</span> s[maxn&lt;&lt;<span class="hljs-number">1</span>],top;<br><span class="hljs-keyword">char</span> ins[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)&lt;/span&gt; &lt;/span&gt;&#123;<br>    dfn[u]=low[u]=++stamp;<br>    s[++top]=u;ins[u]=<span class="hljs-number">0xff</span>;<br>    <span class="hljs-keyword">for</span>(R i(head[u]);i;i=e[i].next) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v=e[i].v;<br>        <span class="hljs-keyword">if</span>(!dfn[v]) &#123;<br>            tarjan(v);<br>            low[u]=min(low[u],low[v]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ins[v]) low[u]=min(low[u],dfn[v]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u]==low[u]) &#123;<br>        cnt++;<br>        <span class="hljs-keyword">while</span>(s[top+<span class="hljs-number">1</span>]!=u) &#123;<br>            belong[s[top]]=cnt;<br>            ins[s[top—]]=<span class="hljs-number">0x0</span>;<br>        &#125;<br>    &#125;<br>&#125;</p><p><span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>);i&lt;=n;i++)<br>    <span class="hljs-keyword">if</span>(belong[i]==belong[i+n])<br>        <span class="hljs-keyword">return</span> write(<span class="hljs-string">&quot;IMPOSSIBLE\n&quot;</span>),<span class="hljs-number">0</span>;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;<br>最后，要找出一组可行解。由上文可知，当$i$为$i+n$的前驱时，$x_i$取<code>true</code>；当$i+n$为$i$的前驱时，$x_i$取<code>false</code>（让前者不成立，后者成立）。在$tarjan$时，标号数组<code>belong</code>即为反向的拓扑序。因此，通过此数组即可得出前驱后继关系，即$i \text{为j的前驱} \Leftrightarrow belong[i]&gt;belong[j]$。<br>代码如下：<br><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>);i&lt;=n;i++)    write((<span class="hljs-keyword">int</span>)(belong[i]&gt;belong[i+n]),<span class="hljs-string">&quot; \n&quot;</span>[i==n]);</code></pre></p><p>最后放出完整代码,<del>不要说我快读毒瘤</del><br>&lt;!—hexoPostRenderEscape:<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span>&lt;/span&gt;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cctype&gt;</span>&lt;/span&gt;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span>&lt;/span&gt;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register int&lt;/span&gt;</p><p><span class="hljs-keyword">namespace</span> quick &#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tp template<span class="hljs-meta-string">&lt;typename Type&gt;</span>&lt;/span&gt;<br>    <span class="hljs-keyword">namespace</span> in &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">getc</span><span class="hljs-params">()</span> &lt;/span&gt;&#123;<br>            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>],<em>p1=buf,</em>p2=buf;<br>            <span class="hljs-keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>,<span class="hljs-built_in">stdin</span>),p1==p2)?EOF:<em>p1++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> </em>s)&lt;/span&gt; &lt;/span&gt;&#123;<br>            <em>s=getc();<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(</em>s)) &#123;<em>s=getc();<span class="hljs-keyword">if</span>(</em>s==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isspace</span>(<em>s)&amp;&amp;</em>s!=EOF) &#123;s++;<em>s=getc();&#125;            </em>s=<span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(Type &amp;x)</span> &lt;/span&gt;&#123;<br>            x=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> k=<span class="hljs-literal">false</span>;<span class="hljs-keyword">char</span> c=getc();<br>            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;k|=(c==<span class="hljs-string">&#x27;-&#x27;</span>);c=getc();<span class="hljs-keyword">if</span>(c==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) &#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>);c=getc();&#125;<br>            x<em>=(k?<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type,<span class="hljs-keyword">typename</span>… Args&gt;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(Type &amp;t,Args &amp;…args)</span> &lt;/span&gt;&#123;<br>            <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>            res+=read(t);res+=read(args…);<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">using</span> in::read;<br>    <span class="hljs-keyword">namespace</span> out &#123;<br>        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>];<span class="hljs-keyword">int</span> p1=<span class="hljs-number">-1</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p2=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>)<span class="hljs-number">-1</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> &lt;/span&gt;&#123;<br>            fwrite(buf,<span class="hljs-number">1</span>,p1+<span class="hljs-number">1</span>,<span class="hljs-built_in">stdout</span>);<br>            p1=<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)&lt;/span&gt; &lt;/span&gt;&#123;<br>            <span class="hljs-keyword">if</span>(p1==p2) flush();<br>            buf[++p1]=c;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> </em>s)&lt;/span&gt; &lt;/span&gt;&#123;<br>            <span class="hljs-keyword">while</span>(<em>s!=<span class="hljs-string">&#x27;\0&#x27;</span>) putc(</em>s),s++;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> <em>s)&lt;/span&gt; &lt;/span&gt;&#123;<br>            <span class="hljs-keyword">while</span>(</em>s!=<span class="hljs-string">&#x27;\0&#x27;</span>) putc(*s),s++;<br>        &#125;<br>        <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Type x)</span> &lt;/span&gt;&#123;<br>            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> p=<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) &#123;putc(<span class="hljs-string">&#x27;-&#x27;</span>);x=-x;&#125;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) putc(<span class="hljs-string">&#x27;0&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(;x;x/=<span class="hljs-number">10</span>) buf[++p]=x%<span class="hljs-number">10</span>+<span class="hljs-number">48</span>;<br>            <span class="hljs-keyword">for</span>(;p!=<span class="hljs-number">-1</span>;p—) putc(buf[p]);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)&lt;/span&gt; &lt;/span&gt;&#123;putc(c);&#125;<br>        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type,<span class="hljs-keyword">typename</span>… Args&gt;<br>        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Type t,Args …args)</span> &lt;/span&gt;&#123;<br>            write(t);write(args…);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">using</span> out::write;<br>    <span class="hljs-keyword">using</span> out::flush;<br>    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type &amp;a,<span class="hljs-keyword">const</span> Type &amp;b)&lt;/span&gt; &lt;/span&gt;&#123;<br>        <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> b;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type &amp;a,<span class="hljs-keyword">const</span> Type &amp;b)&lt;/span&gt; &lt;/span&gt;&#123;<br>        <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Type &amp;a,Type &amp;b)</span> &lt;/span&gt;&#123;<br>        a^=b^=a^=b;<br>    &#125;<br>    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type &amp;a)&lt;/span&gt; &lt;/span&gt;&#123;<br>        <span class="hljs-keyword">return</span> a&gt;=<span class="hljs-number">0</span>?a:-a;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> tp&lt;/span&gt;<br>&#125;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> quick;</p><p><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">20</span>,inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">int</span> n,m;</p><p><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;&lt;/span&gt;<br>    <span class="hljs-keyword">int</span> v,next;<br>    Edge(<span class="hljs-keyword">int</span> v=<span class="hljs-number">0</span>,<span class="hljs-keyword">int</span> next=<span class="hljs-number">0</span>) :v(v),next(next) &#123;&#125;<br>&#125;e[maxn&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-keyword">int</span> head[maxn&lt;&lt;<span class="hljs-number">1</span>],k;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;u,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v)&lt;/span&gt; &lt;/span&gt;&#123;<br>    e[++k]=Edge(v,head[u]);<br>    head[u]=k;<br>&#125;</p><p><span class="hljs-keyword">int</span> low[maxn&lt;&lt;<span class="hljs-number">1</span>],dfn[maxn&lt;&lt;<span class="hljs-number">1</span>],stamp,belong[maxn&lt;&lt;<span class="hljs-number">1</span>],cnt;<br><span class="hljs-keyword">int</span> s[maxn&lt;&lt;<span class="hljs-number">1</span>],top;<br><span class="hljs-keyword">char</span> ins[maxn&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)&lt;/span&gt; &lt;/span&gt;&#123;<br>    dfn[u]=low[u]=++stamp;<br>    s[++top]=u;ins[u]=<span class="hljs-number">0xff</span>;<br>    <span class="hljs-keyword">for</span>(R i(head[u]);i;i=e[i].next) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;v=e[i].v;<br>        <span class="hljs-keyword">if</span>(!dfn[v]) &#123;<br>            tarjan(v);<br>            low[u]=min(low[u],low[v]);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ins[v]) low[u]=min(low[u],dfn[v]);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfn[u]==low[u]) &#123;<br>        cnt++;<br>        <span class="hljs-keyword">while</span>(s[top+<span class="hljs-number">1</span>]!=u) &#123;<br>            belong[s[top]]=cnt;<br>            ins[s[top—]]=<span class="hljs-number">0x0</span>;<br>        &#125;<br>    &#125;<br>&#125;</p><p><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)&lt;/span&gt; &lt;/span&gt;&#123;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE&lt;/span&gt;<br>    freopen(<span class="hljs-string">&quot;sat.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-built_in">stdin</span>);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span>&lt;/span&gt;<br>    read(n,m);<br>    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>);i&lt;=m;i++) &#123;<br>        R u,a,v,b;<br>        read(u,a,v,b);<br>        AddEdge(u+n<em>(a^<span class="hljs-number">1</span>),v+n</em>(b&amp;<span class="hljs-number">1</span>));<br>        AddEdge(v+n<em>(b^<span class="hljs-number">1</span>),u+n</em>(a&amp;<span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>);i&lt;=(n&lt;&lt;<span class="hljs-number">1</span>);i++) <span class="hljs-keyword">if</span>(!dfn[i]) tarjan(i);<br>    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>);i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(belong[i]==belong[i+n])<br>            <span class="hljs-keyword">return</span> write(<span class="hljs-string">&quot;IMPOSSIBLE\n&quot;</span>),flush(),<span class="hljs-number">0</span>;<br>    write(<span class="hljs-string">&quot;POSSIBLE\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>);i&lt;=n;i++)<br>        write((<span class="hljs-keyword">int</span>)(belong[i]&gt;belong[i+n]),<span class="hljs-string">&quot; \n&quot;</span>[i==n]);<br>    flush();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;&lt;/code&gt;&lt;/pre&gt;:hexoPostRenderEscape—&gt;</p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷1587 [NOI2016]循环之美 题解</title>
    <link href="/2020/09/06/cyclebuity/"/>
    <url>/2020/09/06/cyclebuity/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1587">题面</a></p><h1 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h1><p>给定$n,m,k$,求对于$1\le x \le n,1\le y\le m$，$\frac{x}{y}$满足数值上互不相等且在$k$进制下为纯循环小数的个数。</p><p>从小数部分第一位开始的循环小数，称为纯循环小数。特别地，整数为纯循环小数。</p><h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>要满足数值上互不相等，只需统计最简分数，即$x\perp y$即可。</p><p>接下来要判定纯循环小数。</p><h3 id="引理：-frac-x-y-x-perp-y-在-k-进制下是循环小数当且仅当-y-perp-k"><a href="#引理：-frac-x-y-x-perp-y-在-k-进制下是循环小数当且仅当-y-perp-k" class="headerlink" title="引理：$\frac{x}{y},(x\perp y)$在$k$进制下是循环小数当且仅当$y\perp k$"></a>引理：$\frac{x}{y},(x\perp y)$在$k$进制下是循环小数当且仅当$y\perp k$</h3><p>证明：</p><p>设$\frac{x}{y}$为纯循环最简小数，在$k$进制下其循环节长为$l$。</p><p>由纯循环小数定义可知$\frac{x}{y}k^l-\frac{x}{y}=\frac{x}{y}\left(k^l-1\right)\in Z$（$Z$为整数集）。</p><p>又$x\perp y$，则$y|\left(k^l-1\right)$。</p><p>接下来反证。假设$y\not\perp k$。因为有$k^l \not\perp \left(k^l-1\right)$，即$k\not\perp \left(k^l-1\right)$，可推出$y\not \perp \left(k^l-1\right)$，与上文结论矛盾。</p><p>证毕。</p><h3 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h3><p>于是，问题转化为了求$\sum<em>{x=1}^n\sum</em>{y=1}^m\left[x\perp y\right]\left[y\perp k\right]$。</p><p>反演并改变枚举顺序可得</p><script type="math/tex; mode=display">\sum_{x=1}^n\sum_{y=1}^m\left[x\perp y\right]\left[y\perp k\right]\\\\=\sum_{x=1}^n\sum_{y=1}^m\left[y\perp k\right]\sum_{d|x,d|y}\mu(d)\\\\=\sum_{d=1}^{min(n,m)}\mu(d)\left[d\perp k\right]\lfloor\frac{n}{d}\rfloor\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\left[y\perp k\right]\\\\</script><p>设$f\left(n,k\right)=\sum<em>{i=1}^n\left[i\perp k\right],g\left(n,k\right)=\sum</em>{i-1}^n\mu(i)\left[i\perp k\right]$，则$\sum<em>{x=1}^n\sum</em>{y=1}^m\left[x\perp y\right]\left[y\perp k\right]=\sum_{d=1}^{min(n,m)}\mu(d)\left[d\perp k\right]\lfloor\frac{n}{d}\rfloor f\left(\lfloor\frac{m}{d}\rfloor,k\right)$</p><p>因为平方因子与其他数与它是否互质无关,不妨设$k$无完全平方因子（若有将其除掉）。设$p$为$k$的一个质因子，则对于$f$有</p><script type="math/tex; mode=display">f(n,1)=\sum_{i=1}^n1=n,\\\\f(n,k)= \sum_{i=1}^n\left[i\perp k\right]= \sum_{i=1}^n\left[i\perp \frac{k}{p}\right]-\sum_{i=1}^n\left[i\perp \frac{k}{p}\right]\left[p|i\right]\\\\=f\left(i,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\left[ip\perp \frac{k}{p}\right]=f\left(i,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\left[i\perp \frac{k}{p}\right]\\\\=f\left(i,\frac{k}{p}\right)-f\left(\lfloor\frac{n}{p}\rfloor,\frac{k}{p}\right),\qquad \left(p|k,p\in P\right)</script><p>对于$g$有：</p><script type="math/tex; mode=display">g\left(n,1\right)=\sum_{i=1}^n\mu(i),\\\\g\left(n,k\right)=\sum_{i=1}^n\mu(i)\left[i\perp k\right]=\sum_{i=1}^n\mu(i)\left[i\perp \frac{k}{p}\right]-\sum_{i=1}^n\mu(i)\left[i\perp \frac{k}{p}\right]\left[p|i\right]\\\\=g\left(n,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(ip)\left[ip\perp \frac{k}{p}\right]\\\\=g\left(n,\frac{k}{p}\right)-\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(i)\mu(p)\left[i\perp p\right]\left[i\perp \frac{k}{p}\right]\\\\=g\left(n,\frac{k}{p}\right)-\mu(p)\sum_{i=1}^{\lfloor\frac{n}{p}\rfloor}\mu(i)\left[i\perp k\right]\\\\=g\left(n,\frac{k}{p}\right)+g\left(\lfloor\frac{n}{p}\rfloor,k\right)\qquad \left(p|k,p\in P\right)\\\\\left(\quad \mu(p)=-1 \quad \right)</script><p>以上$P$为质数集，利用了莫比乌斯函数的性质$\mu(ab)=\mu(a)\mu(b)\left[a\perp b\right]$</p><p>于是，对于$k=1$的情况，$f$可$O(1)$求解，$g$使用杜教筛即可。</p><p>对于$k&gt;1$的情况，递归求解即可。</p><p>最后数论分块即可求解。递归部分时间复杂度$O\left(\sqrt n\frac{logk}{loglogk}\right)$，杜教筛部分时间复杂度$O(n^{\frac{2}{3}})$。</p><p>思路来自于11Dimensions。</p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cctype&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> R register int</span><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>;<span class="hljs-keyword">namespace</span> quick &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> tp template<span class="hljs-meta-string">&lt;typename Type&gt;</span></span>    <span class="hljs-keyword">namespace</span> in &#123;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">char</span> <span class="hljs-title">getc</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>],*p1=buf,*p2=buf;            <span class="hljs-keyword">return</span> p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>,<span class="hljs-built_in">stdin</span>),p1==p2)?EOF:*p1++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;            *s=getc();            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isspace</span>(*s)) &#123;*s=getc();<span class="hljs-keyword">if</span>(*s==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isspace</span>(*s)&amp;&amp;*s!=EOF) &#123;s++;*s=getc();&#125;            *s=<span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(Type &amp;x)</span> </span>&#123;            x=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> k=<span class="hljs-literal">false</span>;<span class="hljs-keyword">char</span> c=getc();            <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isdigit</span>(c)) &#123;k|=(c==<span class="hljs-string">&#x27;-&#x27;</span>);c=getc();<span class="hljs-keyword">if</span>(c==EOF) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;            <span class="hljs-keyword">while</span>(<span class="hljs-built_in">isdigit</span>(c)) &#123;x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-number">48</span>);c=getc();&#125;            x*=(k?<span class="hljs-number">-1</span>:<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type,<span class="hljs-keyword">typename</span>... Args&gt;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(Type &amp;t,Args &amp;...args)</span> </span>&#123;            <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;            res+=read(t);res+=read(args...);            <span class="hljs-keyword">return</span> res;        &#125;    &#125;    <span class="hljs-keyword">using</span> in::read;    <span class="hljs-keyword">namespace</span> out &#123;        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>];<span class="hljs-keyword">int</span> p1=<span class="hljs-number">-1</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> p2=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">21</span>)<span class="hljs-number">-1</span>;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> </span>&#123;            fwrite(buf,<span class="hljs-number">1</span>,p1+<span class="hljs-number">1</span>,<span class="hljs-built_in">stdout</span>);            p1=<span class="hljs-number">-1</span>;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;            <span class="hljs-keyword">if</span>(p1==p2) flush();            buf[++p1]=c;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;            <span class="hljs-keyword">while</span>(*s!=<span class="hljs-string">&#x27;\0&#x27;</span>) putc(*s),s++;        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *s)</span> </span>&#123;            <span class="hljs-keyword">while</span>(*s!=<span class="hljs-string">&#x27;\0&#x27;</span>) putc(*s),s++;        &#125;        <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Type x)</span> </span>&#123;            <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> buf[<span class="hljs-number">30</span>];<span class="hljs-keyword">int</span> p=<span class="hljs-number">-1</span>;            <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>) &#123;putc(<span class="hljs-string">&#x27;-&#x27;</span>);x=-x;&#125;            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>) putc(<span class="hljs-string">&#x27;0&#x27;</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(;x;x/=<span class="hljs-number">10</span>) buf[++p]=x%<span class="hljs-number">10</span>+<span class="hljs-number">48</span>;            <span class="hljs-keyword">for</span>(;p!=<span class="hljs-number">-1</span>;p--) putc(buf[p]);        &#125;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> &amp;c)</span> </span>&#123;putc(c);&#125;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type,<span class="hljs-keyword">typename</span>... Args&gt;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Type t,Args ...args)</span> </span>&#123;            write(t);write(args...);        &#125;    &#125;    <span class="hljs-keyword">using</span> out::write;    <span class="hljs-keyword">using</span> out::flush;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type &amp;a,<span class="hljs-keyword">const</span> Type &amp;b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> b;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type &amp;a,<span class="hljs-keyword">const</span> Type &amp;b)</span> </span>&#123;        <span class="hljs-keyword">if</span>(a&lt;b) <span class="hljs-keyword">return</span> a;        <span class="hljs-keyword">return</span> b;    &#125;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Type &amp;a,Type &amp;b)</span> </span>&#123;        a^=b^=a^=b;    &#125;    <span class="hljs-function">tp <span class="hljs-keyword">inline</span> Type <span class="hljs-title">abs</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Type &amp;a)</span> </span>&#123;        <span class="hljs-keyword">return</span> a&gt;=<span class="hljs-number">0</span>?a:-a;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> tp</span>&#125;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> quick;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1e6</span>+<span class="hljs-number">20</span>,limit=<span class="hljs-number">1e6</span>,inf=<span class="hljs-number">0x3f3f3f3f</span>;<span class="hljs-keyword">int</span> n,m,k;<span class="hljs-keyword">int</span> mu[maxn];<span class="hljs-comment">//g的第一维</span><span class="hljs-keyword">int</span> prime[maxn],cnt,pk[maxn],tot;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k)</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span> not_prime[maxn];    mu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">2</span>);i&lt;=limit;i++) &#123;        <span class="hljs-keyword">if</span>(~not_prime[i]) prime[cnt++]=i,mu[i]=<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(R j(<span class="hljs-number">0</span>);j&lt;cnt&amp;&amp;prime[j]&lt;=limit/i;j++) &#123;            not_prime[i*prime[j]]=<span class="hljs-number">0xff</span>;            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            mu[i*prime[j]]=-mu[i];        &#125;    &#125;    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>);i&lt;=limit;i++) mu[i]+=mu[i<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">0</span>);i&lt;cnt&amp;&amp;prime[i]&lt;=k;i++) &#123;        <span class="hljs-keyword">while</span>(k%(prime[i]*prime[i])==<span class="hljs-number">0</span>) k/=prime[i];        <span class="hljs-keyword">if</span>(k%prime[i]==<span class="hljs-number">0</span>) pk[tot++]=prime[i];    &#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> f1(i) i</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> g1(i) mu[i]</span><span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,ll&gt; G1;<span class="hljs-function">ll <span class="hljs-title">GetG1</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;n)</span> </span>&#123;    <span class="hljs-keyword">if</span>(n&lt;=limit) <span class="hljs-keyword">return</span> g1(n);    <span class="hljs-keyword">if</span>(G1[n]) <span class="hljs-keyword">return</span> G1[n];    ll ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">2</span>),j;i&lt;=n;i=j+<span class="hljs-number">1</span>) &#123;        j=n/(n/i);        ans-=(ll)(j-i+<span class="hljs-number">1</span>)*GetG1(n/i);    &#125;    <span class="hljs-keyword">return</span> G1[n]=ans;&#125;<span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-keyword">int</span>,ll&gt; &gt; F,G;<span class="hljs-function">ll <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;n,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;k,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;now=<span class="hljs-number">0</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ll(f1(n));    <span class="hljs-keyword">if</span>(F[n][k]) <span class="hljs-keyword">return</span> F[n][k];    <span class="hljs-keyword">return</span> F[n][k]=f(n,k/pk[now],now+<span class="hljs-number">1</span>)-f(n/pk[now],k/pk[now],now+<span class="hljs-number">1</span>);&#125;<span class="hljs-function">ll <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;n,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;k,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;now=<span class="hljs-number">0</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(k==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> GetG1(n);    <span class="hljs-keyword">if</span>(G[n][k]) <span class="hljs-keyword">return</span> G[n][k];    <span class="hljs-keyword">return</span> G[n][k]=g(n,k/pk[now],now+<span class="hljs-number">1</span>)+g(n/pk[now],k,now);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> ONLINE_JUDGE</span>    freopen(<span class="hljs-string">&quot;bea.in&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,<span class="hljs-built_in">stdin</span>);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    read(n,m,k);    Init(k);    ll ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(R i(<span class="hljs-number">1</span>),j;i&lt;=n&amp;&amp;i&lt;=m;i=j+<span class="hljs-number">1</span>) &#123;        j=min(n/(n/i),m/(m/i));        ans+=(ll)(g(j,k)-g(i<span class="hljs-number">-1</span>,k))*(n/i)*f(m/i,k);    &#125;    write(ans,<span class="hljs-string">&#x27;\n&#x27;</span>);    flush();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><del>注意n和m不要交换，我就是因为这个调了一上午</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>题解</tag>
      
      <tag>数学</tag>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
